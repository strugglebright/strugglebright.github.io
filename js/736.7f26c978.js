"use strict";(self.webpackChunkbright_blog=self.webpackChunkbright_blog||[]).push([[736],{25736:function(n,e){e.A=[{articleName:"实现一个谷歌扩展插件",articleTitle:"实现一个下载图片的谷歌扩展插件",articleTxt:'实现一个谷歌扩展，最核心的内容就是配置manifest.json文件 _br_ 配置好manifest.json文件后在浏览器中打开chrome://extensions/ _br_ 选择开发者模式，然后点击加载已解压的扩展程序，选择你的项目文件夹，然后就可以看到你的插件了\n    _br_ manifest.json文件 _br_ <pre><code>{\n  "manifest_version": 2,\n  "name": "Bright的插件",\n  "version": "1.0",\n  "description": "基于vue2的谷歌插件",\n  "permissions": [\n    "activeTab","downloads"\n  ],\n  "browser_action": {\n    "default_popup": "index.html",\n    "default_icon": {\n      "16": "bright-16.png",\n      "48": "bright-48.png",\n      "128": "bright-128.png"\n    }\n  },\n  "icons": {\n    "16": "bright-16.png",\n    "48": "bright-48.png",\n    "128": "bright-128.png"\n  }\n}</code></pre>_br_\n上面这段配置中需要注意permissions属性,这里是设置相关权限的 _br_\n"activeTab":这个权限允许扩展程序访问当前活动标签页的内容。 _br_\n例如，当用户点击浏览器工具栏中的扩展按钮时，扩展程序可以读取或修改当前活动标签页的 DOM、执行脚本等。使用这个权限，你可以获取当前标签页的 URL、标题等信息，或者注入自定义的 JavaScript 代码到页面中 _br__hr_\n"downloads":这个权限允许扩展程序管理用户的下载项。 _br_\n例如，扩展程序可以查询、取消、暂停或恢复下载任务，还可以监听下载事件。使用这个权限，你可以编写功能来自动下载文件、监控下载进度、处理下载完成后的操作等。_br_\n总结来说，这两个权限的组合使得你的扩展程序能够与当前活动标签页进行交互（如获取页面信息或注入脚本）。管理和控制用户的下载任务（如启动下载、监控下载状态等）。_br_\n代码实现具体功能_br_<pre><code>methods: {\ndownloadImages() {\n    // 查询当前活动窗口中的活动标签页\n  //  tabs 是一个包含匹配标签页信息的数组\n  //  { active: true, currentWindow: true } 是查询条件，表示只查询当前活动窗口中的活动标签页\n  chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n    // chrome.tabs.executeScript 用于在指定的标签页中执行 JavaScript 代码\n    // tabs[0].id 是活动标签页的 ID\n    // code 是要执行的 JavaScript 代码\n      // 在活动标签页中执行脚本以获取所有图片的 URL\n    chrome.tabs.executeScript(tabs[0].id, {\n      code: `var images = document.getElementsByTagName(\'img\'); var imageUrls = [];\n        for (var i = 0; i < images.length; i++) { imageUrls.push(images[i].src); } imageUrls;`\n    }, (results) => {\n        // 检查是否成功获取到图片 URL\n      if (results && results[0]) {\n        // 遍历每个图片 URL 并下载图片\n        results[0].forEach(url => {\n          chrome.downloads.download({ url: url });\n        });\n      } else {\n        console.error("No images found on the page.");\n      }\n    });\n  });\n}</code></pre>_br_\n这个示例是在vue2项目写的,最终将manifest.json文件放到打包后的dist文件中即可。 _br_当然dist文件夹名称可以自行更改,之后打开谷歌浏览器,选择加载已解压的扩展程序，选择你的项目文件夹即可。_br_\n<img src="'.concat("https://i.postimg.cc/BQSgy6jm/info17.jpg",'" alt="/" />\n<img src="').concat("https://i.postimg.cc/VvRFvyV9/info18.jpg",'" alt="/" />\n<img src="').concat("https://i.postimg.cc/FsTZQ4cN/info19.jpg",'" alt="/" />\n')},{articleName:"npm 或 yarn管理依赖常见疑问",articleTitle:"npm 或 yarn管理项目依赖时常见的疑问",articleTxt:'在其他站点上看到这几个问题觉得很有意思，和大家分享下。 _br_ \n  这里简单说下yarn,对于npm不太了解的朋友可以自行查询下基础知识。 _br_ \n  yarn 是为弥补 npm 的一些缺陷而出现的用以代替 npm 的 js 包管理工具。 _br_ \n  为什么说是弥补呢？ _br_ \n  1、npm install 的时候真的慢...进度条就给你卡在那不动。 _br_ \n  2、同一个项目，安装的时候无法保持一致性。由于 package.json 文件中版本号的特点，下面三个版本号在安装的时候代表不同的含义。 _br_ \n  "5.0.3", 表示安装指定的 5.0.3 版本， _br_ \n  "~5.0.3", 表示安装 5.0.X 中最新的版本， _br_\n  "^5.0.3" 表示安装 5.X.X 中最新的版本。 _br_ \n  这就麻烦了，常常会出现同一个项目，有的同事是 OK 的，有的同事会由于安装的版本不一致出现 bug。 _br__hr_ \n\n问题1：项目依赖出现问题怎么办？删了重装，即先删除 node_modules 再重新 install，那这样的操作会不会存在风险？ _br_\n\n回答：风险虽然是有的，但是架不住这样操作简单省事啊。反正我项目中遇到这种问题都是这么解决的。 _br_ \n不过需要注意lock文件,如果安装有问题可能是根据lock安装导致的,这个时候不妨删除掉lock再重新安装。\n直接删除 node_modules 并重新安装依赖虽然可以解决很多依赖相关的问题，但这种方法存在一些潜在的风险：\n丢失本地配置：某些依赖可能依赖于本地配置文件（如编译工具、环境变量等），这些配置在重新安装后可能会丢失。\n版本不一致：如果项目中有多个开发者，直接删除并重新安装可能会导致不同开发者之间的依赖版本不一致，从而引发不可预期的错误。\n时间成本：重新安装所有依赖会花费一定的时间，特别是在依赖较多的情况下。 _br__hr_\n\n\n问题2：把所有依赖都安装到 dependencies 中，不区分 devDependencies 会有问题吗？ _br_ \n回答：将所有依赖都安装到 dependencies 中而不区分 devDependencies 貌似除了增大体积也不会出什么事。 _br_ 只是会导致生产环境中包含不必要的开发依赖，这会增加应用的体积和部署时间。 _br_ \n建议：根据依赖的实际用途将其分类到 dependencies 或 devDependencies 中。例如，将只在开发过程中使用的工具（如测试框架、构建工具）放在 devDependencies 中。 _br__hr_ \n\n问题3：我们的应用依赖了 pkg-a 和 pkg-b，同时 pkg-a 也依赖了 pkg-b，那么 pkg-b 会被多次安装或重复打包吗？ _br_ \n回答：完全不用担心,npm 会自动处理这种情况，确保每个包只被安装一次，即使它被多个依赖引用。 _br_ 它会使用扁平化依赖树的方式，将共享的依赖提升到顶层。\nyarn 也会处理这种情况，通过链接机制避免重复安装相同的包。 _br__hr_ \n\n问题4：一个项目中，我使用 npm 别人使用 yarn，这会引发什么问题？ _br_ \n\n回答：可能会导致冲突。 _br_ \n兼容性问题：npm 和 yarn 在处理依赖解析和安装上有一些差异，因此同一个项目的 package.json 文件在不同包管理器下可能会有不同的行为。 _br_ \n锁文件格式不同：npm 使用 package-lock.json，而 yarn 使用 yarn.lock。两者的锁文件格式不同，因此在切换包管理器时需要特别注意。 _br_ \n依赖冲突：由于包管理器的行为不同，可能会导致依赖冲突或版本不一致的问题。 _br_ \n强烈建议尽量统一团队内的包管理器，或者在项目文档中明确说明使用的包管理器及其版本。 _br__hr_ \n\n问题5：我们是否要提交 lockfile(package-lock.json/yarn.lock) 到项目仓库呢？ _br_ \n回答：是的,个人建议也要提交上去。 _br_ \n提交 package-lock.json 或 yarn.lock 文件到项目仓库是一个好习惯，这样可以确保团队成员在安装依赖时使用的是相同的版本，避免因版本不一致导致的问题。 _br__hr_ \n\n问题6：lockfile 在 git 操作时，时常会出现大量的冲突，你是怎么解决的呢？ _br_ \n回答：手动合并：当 lockfile 出现冲突时，可以手动合并这些文件，但需要特别小心，因为错误的合并可能导致依赖关系混乱。 _br_ \n定期更新：定期运行 npm install 或 yarn install 来更新 lockfile，可以减少冲突的频率。 _br_ \n使用工具：可以使用一些工具来帮助管理和更新 lockfile，例如 renovate 或 dependabot，这些工具可以自动检测和更新依赖。'},{articleName:"visibilitychange 事件",articleTitle:"visibilitychange 页面监听事件",articleTxt:'一个有意思的HTML5事件, visibilitychange事件，是浏览器新添加的一个事件。 _br_\n  当浏览器的某个标签页切换到后台，或从后台切换到前台时就会触发该消息，现在主流的浏览器都支持该消息了。 _br_\n  虽然这只是一个简单的功能，但是能够为广大的采用HTML5开发游戏的开发者提供方便，比如用户正在玩游戏时，突然切换到后台去发一条短信或打一个电话，再切换到游戏，\n  那么开发者就需要捕捉对这些突发情形进行处理，当游戏切换到后台时就暂停游戏，从后台切换回来时，又能允许用户继续游戏。 _br_\n  <document.addEventListener>通过document的hidden属性可以判断标签是否可见。true时代表标签不可见。 _br_\n  这个事件适合在标签不可见的时候减少网络请求、服务器压力等，也可以做一些好玩的事情，比如改变网页标题的文字。 _br_\n    <pre><code>document.addEventListener("visibilitychange", function(){\n      document.title = document.hidden ? "用户离开了" : "用户回来了";\n});</code></pre>'},{articleName:"js设计模式-状态模式",articleTitle:"js设计模式-状态模式",articleTxt:'<img alt="" src="'.concat("https://i.postimg.cc/jqQcZNSW/info1.png","\" /> _br_\n  <pre><code>\n  <template>\n  <div class=\"cooker\">\n    <img src=\"../assets/gaoyaguo.png\" alt=\".\" />\n    <div class=\"flex typeName\">\n      <div>状态:{{ typeName }}</div>\n      <div>描述:{{ desction }}</div>\n    </div>\n    <div class=\"flex buttonSubmit\">\n      <div @click=\"powerOn\">接电</div>\n      <div @click=\"powerOff\">断电</div>\n      <div @click=\"startCook\">开始煮饭</div>\n      <div @click=\"open\">开盖</div>\n      <div @click=\"close\">盖上</div>\n    </div>\n  </div>\n  </template>\n  </code></pre> _br_\n  <pre><code>\n<script>\nimport Cooker from \"./cookerData.js\";\nconst CookerCent = new Cooker();\nexport default {\n  data() {\n    return {\n      typeName: \"~\",\n      desction: \"~\",\n    };\n  },\n  mounted() {},\n  methods: {\n    powerOn() {\n      CookerCent.changeSwitch('powerOn');\n      this.desction = CookerCent.getTypeName();\n      this.typeName = CookerCent.getDesction();\n    },\n    powerOff() {\n      CookerCent.changeSwitch('powerOff');\n      this.desction = CookerCent.getTypeName();\n      this.typeName = CookerCent.getDesction();\n    },\n    startCook() {\n      CookerCent.changeSwitch('startCook');\n      this.desction = CookerCent.getTypeName();\n      this.typeName = CookerCent.getDesction();\n    },\n    open() {\n      CookerCent.changeSwitch('open');\n      this.desction = CookerCent.getTypeName();\n      this.typeName = CookerCent.getDesction();\n    },\n    close() {\n      CookerCent.changeSwitch('close');\n      this.desction = CookerCent.getTypeName();\n      this.typeName = CookerCent.getDesction();\n    },\n  },\n};\n<\/script>\n \n<style>\n.flex {\n  display: flex;\n}\nbutton {\n  cursor: pointer;\n}\n.cooker{\n  width: 500px;\n  margin: 0 auto;\n}\nimg{\n  display: block;\n  width: 300px;\n  margin: 0 auto;\n}\n.typeName{\n  width: 100%;\n  justify-content: center;\n  margin: 20px 0;\n}\n.typeName>div{\n  width: 50%;\n}\n.typeName>div:nth-child(1){\n  margin-right: 20px;\n}\n.buttonSubmit{\n  width: 100%;\n  justify-content: center;\n}\n.buttonSubmit>div{\n  width:calc((100% - 30px)/4);\n  margin-right: 10px;\n  background-color: #ededed;\n  border-radius: 5px;\n  cursor: pointer;\n  padding: 5px 0;\n  text-align: center;\n}\n.buttonSubmit>div:last-child{\n  margin-right: 0;\n}\n</style></code></pre> _br_\n  <pre><code>class Cooker {\n    constructor() {      //  constructor 是状态变量、固定写法\n        this.cookerType = new PowerOn(this)  // 默认状态 已接电  此时的 this 承接上下文 \n    }\n    changeSwitch(cookerType) {    // 外部调用下面5个类中的方法  默认当前是 已接电  PowerOn、所以点击外部任何按钮、都是调用这个类下面的函数、\n        this.cookerType[cookerType]()\n    }\n    getTypeName() {\n        return this.cookerType.typeName   //  这里的typeName 是下面5个类中的共有属性  this.cookerType 此时代表的就是当前点击时的类、比如默认实例化的类PowerOn、点击的任何函数都是这个类里面的\n    }\n    getDesction() {\n        return this.cookerType.desction    //  同上\n    }\n}\nclass PowerOn {   // 当前类的状态是已接电、里面的5个函数分别做了处理、无法执行下一步的会提示文字、可以执行下一步的、实例化下一步的类\n    constructor(cooker) {   //  构造函数传入的参数就是上面的this、可以理解为固定写法\n        this.cooker = cooker     //  this.cooker 相当于 Cooker 里面的this \n    }\n    powerOn() {\n        this.typeName = '当前是接电状态'\n        this.desction = '已接电'\n    }\n    powerOff() {\n    this.cooker.cookerType = new PowerOff(this.cooker)     // 当前状态是已接电、这个函数是断电、点击后指向断电的类、之后操作和前面一样、在格子的类中处理各自的状态\n    }\n    startCook() {\n    this.cooker.cookerType = new StartCook(this.cooker)\n    }\n    open() {\n        this.typeName = '当前是接电状态'\n        this.desction = '不能开盖、会爆炸'\n    }\n    close() {\n        this.typeName = '当前状态-已接电'\n        this.desction = '已经盖上了'\n    }\n}\nclass PowerOff {\n    constructor(cooker) {\n        this.cooker = cooker\n        this.typeName = '当前状态-断电'\n        this.desction = '已断电'\n    }\n    powerOn() {\n        this.cooker.cookerType = new PowerOn(this.cooker)  \n    }\n    powerOff() {\n        this.typeName = '当前状态-断电'\n        this.desction = '已断电'\n    }\n    startCook() {\n        this.typeName = '当前状态-断电'\n        this.desction = '不能煮饭'\n    }\n    open() {\n        this.typeName = '当前状态-断电'\n        this.desction = '可以开盖'\n    }\n    close() {\n        this.cooker.cookerType = new Close(this.cooker)\n    }\n}\nclass StartCook {\n    constructor(cooker) {\n        this.cooker = cooker\n        this.typeName = '当前状态-煮饭'\n        this.desction = '开始煮饭222'\n    }\n    powerOn() {\n        this.typeName = '当前状态-煮饭'\n        this.desction = '已接电'\n    }\n    powerOff() {\n        this.cooker.cookerType = new PowerOff(this.cooker)\n    }\n    startCook() {\n        this.typeName = '当前状态-煮饭'\n        this.desction = '正在煮饭'\n    }\n    open() {\n        this.typeName = '当前状态-煮饭'\n        this.desction = '不能开盖、会爆炸'\n    }\n    close() {\n        this.typeName = '当前状态-煮饭'\n        this.desction = '已经盖上了'\n    }\n}\nclass Open {\n    constructor(cooker) {\n        this.cooker = cooker\n        this.typeName = '当前状态-开盖'\n        this.desction = ''\n    }\n    powerOn() {\n        this.typeName = '当前状态-开盖'\n        this.desction = '接电中、不能打开'\n    }\n    powerOff() {\n        this.cooker.cookerType = new PowerOff(this.cooker)\n    }\n    startCook() {\n        this.typeName = '当前状态-开盖'\n        this.desction = '开盖中、不能煮饭'\n    }\n    open() {\n        this.typeName = '当前状态-开盖'\n        this.desction = '已开盖'\n    }\n    close() {\n        this.cookerType = new Close(this.cooker)\n    }\n}\nclass Close {\n    constructor(cooker) {\n        this.cooker = cooker\n        this.typeName = '当前状态-关盖'\n        this.desction = ''\n    }\n    powerOn() {\n        this.cooker.cookerType = new PowerOn(this.cooker)\n    }\n    powerOff() {\n        this.cooker.cookerType = new PowerOff(this.cooker)\n    }\n    startCook() {\n        this.cooker.cookerType = new StartCook(this.cooker)\n    }\n    open() {\n        this.cooker.cookerType = new Open(this.cooker)\n    }\n    close() {\n        this.typeName = '当前状态-关盖'\n        this.desction = '已关盖'\n    }\n}\nexport default Cooker</code></pre>")},{articleName:"addEventListener 绑在哪？",articleTitle:"addEventListener 应该添加到 window 还是 document？",articleTxt:" \n  addEventListener的作用： _br_\n  MDN中的解释是EventTarget.addEventListener() 方法将指定的监听器注册到 EventTarget 上，当触发指定的事件时，指定的回调函数就会被执行。事件目标可以是一个文档上的元素 Element、Document 和 Window，也可以是任何支持事件的对象（比如 XMLHttpRequest）。 _br_\n  通俗易懂点讲 addEventListener 就是网页和用户“对话”的工具。_br_你告诉浏览器：“当某某事情发生时，记得帮我做这个动作”，而浏览器会忠实地执行你的指令。 _br__hr_\n  那么问题来了，addEventListener 应该添加到 window 还是 document？ _br_\n  window、document都可以添加。 _br_\n  按照标准来说，任何事件都会经过三个阶段，捕获，目标元素，冒泡。 _br_\n  事件不管是捕获还是冒泡，都会经过window和document。因此，你使用window.addEventListener和document.addEventListener来处理页面上的事件，\n  区别仅仅在于，不同事件模型上，处理的顺序不一样： _br_\n  捕获，window先于document _br_\n  冒泡，document先于window _br_\n  addEventListener的第三个参数来使用不同的事件模型。 _br_\n  true代表我们想在捕获阶段处理事件，false代表我们想在冒泡阶段处理事件，默认是false。 _br__hr_\n  window 作用域是整个浏览器窗口，适用事件类型包含resize、load、hashchange等。事件传播阶段是全局事件。 _br_\n  <pre><code>\n  // 监听窗口大小变化（全局事件）\nwindow.addEventListener('resize', function(event) {\n    console.log('窗口尺寸变化:', window.innerWidth, 'x', window.innerHeight);\n});\n\n// 监听页面完全加载完成\nwindow.addEventListener('load', function() {\n    console.log('页面所有资源加载完毕');\n});\n  </code></pre> _br_\n  document 作用域是DOM 文档根节点，适用事件类型包含click、keydown、DOMContentLoaded等。事件传播阶段是文档内元素事件。 _br_\n  <pre><code>\n  // 监听文档内任意点击事件（冒泡阶段触发）\n  document.addEventListener('click', function(event) {\n      console.log('点击元素:', event.target.tagName);\n  });\n  \n  // 监听键盘按下事件（捕获阶段触发）\n  document.addEventListener('keydown', function(event) {\n      if (event.key === 'Enter') {\n          console.log('按下了回车键');\n      }\n  }, true); // 第三个参数为 true 表示捕获阶段触发\n  </code></pre> _br_\n  综上所述，window.addEventListener 适合全局、与窗口相关的事件。document.addEventListener 适合文档级、与 DOM 内容交互的事件。 _br_\n  我的主要技术栈是vue，addEventListener()方法在我的项目里经常见到是因为主要用它来处理全局事件，比如监听窗口滚动、键盘事件，因为Vue 模板语法无法直接绑定到 window。 _br_\n  补充两点：\n  1、在 Vue 组件的 beforeDestroy 或 unmounted 生命周期中 必须移除全局事件，否则可能导致内存泄漏。\n  2、避免在 window 和 document 重复绑定相同事件，这种事件冲突可能因冒泡/捕获机制导致逻辑混乱。"},{articleName:"Unchecked runtime.lastError",articleTitle:"Chrome报错：Unchecked runtime.lastError",articleTxt:'报错：<img alt="/" src="'.concat("https://i.postimg.cc/W1fX0vbX/info6.jpg",'"/> _br_\n  项目背景、安装了 Express 框架，目的是为了快速创建一个web服务器。 _br_\n  创建成功后，控制台出现了报错，而在这之前没有出现过这个错误，所以一直在纠结是不是框架本身的问题。 _br_\n错误原因：这个错误一般是浏览器与扩展或者插件之间通信有关，排查后定位在了迅雷扩展上。 _br_\n<img alt="/" src="').concat("https://i.postimg.cc/CKBJNQRY/info8.jpg",'"/>\n<img alt="/" src="').concat("https://i.postimg.cc/HkL6JxHr/info10.jpg",'"/> _br_\n关闭扩展后，报错消失了！')},{articleName:"node.js 实现第一个接口",articleTitle:"express-generator快速构建node后端项目并实现接口",articleTxt:'express-generator是express官方团队开发者准备的一个快速生成工具，可以非常快速的生成一个基于express开发的框架基础应用。 _br_\n  npm安装 _br_\n  <pre><code>npm install express-generator -g</code></pre> _br_\n  <img alt="/" src="'.concat("https://i.postimg.cc/yNMjryRR/info11.jpg",'" /> _br_\n  <h4>个文件含义及用途</h4>app.js 是项目的主文件（入口文件），相当于vue项目的main.js\nbin: 启动目录 里面包含了一个启动文件\nbin/www 一个启动文件,配置了项目运行的端口信息 默认监听端口是 3000\npackage.json 包描述文件  最重要的是 依赖的模板列表 dependencies依赖列表里面的所有模板 可以通过 npm i / cnpm i  一次性全部安装\npublic:  所有的前端静态资源  html css image  js\nviews: 主要放置后端模板文件\nroutes:  放的是 路由 文件 (默认有两个)，主要在这个目录下开发接口路由主要定义 url 和 资源 的映射关系 ( 一一对应关系 )主要用来接收前端发送的请求响应数据给前端\ndataBase:是我自己新增的一个文件，主要用来配置数据库账号密码和端口以及连接mysql\n<h4>启动项目</h4>SET DEBUG=myapp:* & npm start\n或者 npm start （非debug模式启动）\n运行成功，控制台输出服务运行端口 3000 \nmyapp:server Listening on port 3000 +0ms\n通过浏览器访问 ：http://localhost:3000\n<h4>数据库配置和连接</h4>\n<img alt="/" src="').concat("https://i.postimg.cc/63Ccs4Vm/info12.jpg","\" /> _br_\nconfig.js _br_\n<pre><code>module.exports = {\ndb: {\n  host: \"127.0.0.1\",//如果是操作本地数据库，填写127.0.0.1；如果是远程服务器上的数据库填服务公网ip\n  user: \"root\",//通常为root\n  password: \"xxxxx\",//密码\n  database: \"node_test\"//你所要操作的数据库的名称（是你在mysql中建立的数据库）\n}\n}</code></pre> _br_\ndb.js _br_\n<pre><code>const mysql = require('mysql')\nconst config = require('./config').db</code></pre> _br_\n//连接数据库 _br_\n<pre><code>module.exports = mysql.createConnection(config)</code></pre> _br_\n<h4>接口的开发与引用</h4>在项目的routes目录下写接口，app.js中引用 _br_\nroutes/index.js _br_\n<pre><code>var express = require('express');\nvar router = express.Router();\n//引入数据库连接\nvar db = require('../dataBase/db')\nrouter.get('/', function (req, res, next) {\nres.render('index', { articleName: 'Express' });\n});\nrouter.get('/users', function (req, res, next) {\nres.send('respond with a resource');\n});\n// 完整接口路径，下面可以看到结果 http://localhost:3000/demo\nrouter.get('/demo', function (req, res, next) {\ndb.query(\"select * from t_user\",\n  function (err, result) {\n    if (err) {\n     //('查询错误', err);\n    } else {\n      res.send({\n        code: 200,\n        data: result\n      });\n    }\n  }\n)\n});\nmodule.exports = router;</code></pre> _br_\napp.js主文件 _br_\n<pre><code>var createError = require('http-errors');\nvar express = require('express');\nvar path = require('path');\nvar cookieParser = require('cookie-parser');\nvar logger = require('morgan');\n//一定要在路由之前，配置cors这个中间件，从而解决接口跨域的问题\nvar cors = require('cors')\n// 导入路由模块  -- 接口\nvar indexRouter = require('./routes/index');\nvar app = express();\napp.set('views', path.join(__dirname, 'views'));  // 模板引擎的配置\napp.set('view engine', 'jade');  // 模板引擎的配置  新版引擎从jade换成了pug,貌似是因为jade商标被注册了\napp.use(cors())  //  中间件,解决跨域问题\napp.use(logger('dev')); // 将信息打印到控制台\napp.use(express.json());  // 内置的中间件,将解析的数据放到req.body中\napp.use(express.urlencoded({ extended: false }));// req.body，因为我们采用了application/x-www-form-urlencoded的数据格式，\n// 故我们需要采用对应解析的中间件，express为我们内置了一个express.urlencoded({extended: false})\n// 如果设置为false，那么对URL-encoded的数据的解析采用querystring库\n// 如果设置为true，那么采用qs库，允许将富对象和数组编码为url编码格式，允许使用url编码的json体验\napp.use(cookieParser()); // 中间件,处理每一个cookie,可以获取并设置cookie  获取方式 req.cookie.xxx\napp.use(express.static(path.join(__dirname, 'public')));  // 访问静态文件\n// 注册路由 --接口\napp.use(indexRouter);\n// catch 404 and forward to error handler\napp.use(function (req, res, next) {\nnext(createError(404));\n});\n// error handler\napp.use(function (err, req, res, next) {\nres.locals.message = err.message;\nres.locals.error = req.app.get('env') === 'development' ? err : {};\nres.status(err.status || 500);\nres.render('error');\n});\nmodule.exports = app;</code></pre> _br_\n<h4>结果</h4> _br_\n<img alt=\"/\" src=\"").concat("https://i.postimg.cc/wMHV9x0T/info13.jpg",'" />')},{articleName:"HTTP状态码详解",articleTitle:"HTTP状态码详解",articleTxt:"\n  100：客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 _br__hr_\n\n  101：服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。\n只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 _br__hr_\n\n  102：代表处理将被继续执行。 _br__hr_\n\n  200：请求已成功，请求所希望的响应头或数据体将随此响应返回。 _br__hr_\n\n  201：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。 _br__hr_\n\n  202：服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。\n返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 _br__hr_\n\n  203：服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 _br__hr_\n\n  204：服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。\n如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。\n由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 _br__hr_\n\n  205：服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。\n与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 _br__hr_\n\n  206：服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\n该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。\n响应必须包含如下的头部域：\nContent-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。\nDate  ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。\nExpires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。\n假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。\n假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。\n任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。 _br__hr_\n\n  207：代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 _br__hr_\n\n  300：被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。\n除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。\n如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 _br__hr_\n\n  301：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。\n新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。\n如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。\n注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 _br__hr_\n\n  302：请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。\n如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。\n注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 _br__hr_\n  \n  303：对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。\n新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。\n注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 _br__hr_\n  \n  304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。\n该响应必须包含以下的头信息：\nDate，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。\nETag 和/或 Content-Location，假如同样的请求本应返回200响应。\nExpires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。\n假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。\n假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。\n假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 _br__hr_\n  \n  305：被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。\n注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 _br__hr_\n  \n  306：在最新版的规范中，306状态码已经不再被使用。 _br__hr_\n  \n  307：请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。\n如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 _br__hr_\n  \n  400：1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。\n2、请求参数有误。 _br__hr_\n    \n  401：当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 _br__hr_\t\t<tr>\n  402：该状态码是为了将来可能的需求而预留的。 _br__hr_\t\t<tr>\n  403：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 _br__hr_\t\t<tr>\n  404：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 _br__hr_\t\t<tr>\n  405：请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。\n鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 _br__hr_\t\t<tr>\n  406：请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。\n除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 _br__hr_\t\t<tr>\n  407：与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。 _br__hr_\t\t<tr>\n  408：请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 _br__hr_\t\t<tr>\n  409：由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。\n冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 _br__hr_\t\t<tr>\n  410：被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。\n410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 _br__hr_\t\t<tr>\n  411：服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 _br__hr_\t\t<tr>\n  412：服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 _br__hr_\t\t<tr>\n  413：服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。\n　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 _br__hr_\t\t<tr>\n  414：请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：\n　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。\n　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。\n　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 _br__hr_\t\t<tr>\n  415：对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 _br__hr_\t\t<tr>\n  416：如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。\n　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 _br__hr_\t\t<tr>\n  417：在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 _br__hr_\t\t<tr>\n  421：从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 _br__hr_\t\t<tr>\n  422：从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 _br__hr_\t\t<tr>\n  422：请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked\n　　当前资源被锁定。（RFC 4918 WebDAV） _br__hr_\t\t<tr>\n  424：由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） _br__hr_\t\t<tr>\n  425：在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 _br__hr_\t\t<tr>\n  426：客户端应当切换到TLS/1.0。（RFC 2817） _br__hr_\t\t\t\t<tr>\n428</td>\n通常情况下，428 Precondition Required 的出现是因为客户端没有按照服务器要求的条件进行请求，或请求中缺少了必要的条件信息，导致服务器无法理解该请求。</td>\n</tr><tr>\n  449：由微软扩展，代表请求应当在执行完适当的操作后进行重试。 _br__hr_\t\t<tr>\n  500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 _br__hr_\t\t<tr>\n  501：服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 _br__hr_\t\t<tr>\n  502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 _br__hr_\t\t<tr>\n  503：由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。\n　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 _br__hr_\t\t<tr>\n  504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。\n　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误 _br__hr_\t\t<tr>\n  505：服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 _br__hr_\t\t<tr>\n  506：由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 _br__hr_\n\n  507：服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。 _br__hr_\n  \n  509：服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 _br__hr_\n  \n  510：获取资源所需要的策略并没有没满足。"},{articleName:"虚拟的节点对象",articleTitle:"虚拟的节点对象",articleTxt:'document.createDocumentFragment() 是在浏览器中创建一个文档片段（Document Fragment）的方法。_br_\n  文档片段是一种轻量级的临时容器，用于在内存中构建和操作 DOM 结构，然后将其一次性插入到文档中，以提高性能和效率。_br_\n  通常情况下，向 DOM 中频繁添加、移动、修改元素会触发浏览器的重绘和回流操作，这可能影响性能。_br_使用文档片段可以在内存中进行这些操作，然后一次性将更改应用到文档中，从而减少了频繁的 DOM 操作。_br_\n  下面是一个使用 document.createDocumentFragment() 的简单示例，演示了如何创建一个文档片段，向其中添加一些元素，然后将整个文档片段插入到 DOM 中：_br_\n  <pre><code>let fragment = document.createDocumentFragment();\nfor (let i = 0; i < 10; i++) {\n  let div = document.createElement("div");\n  div.textContent = "Item " + (i + 1);\n  fragment.appendChild(div);\n}\nlet container = document.getElementById("container");\ncontainer.appendChild(fragment);</code></pre>_br_\n  总之，document.createDocumentFragment() 是一个用于创建临时的、离线的 DOM 结构的方法，用于优化复杂的 DOM 操作。'},{articleName:"MutationObserver",articleTitle:"MutationObserver",articleTxt:'MutationObserver在开发中或许不常使用，但是特殊情况下确实可以解决某些问题。_br_\nMutationObserver是JS的API，可以用于观察文档中的 DOM 树变化，并在这些变化发生时执行特定的回调函数。_br_\n介绍一下基本用法，MutationObserver类接收一个回调函数，在标签发生变化时触发，参数mutationsList是MutationRecord对象（后面会详细讲）的数组，参数observer是当前MutationObserver的实例对象；_br_\nobserver实例存在函数observe，传入两个参数第一个是待监听的标签，第二个是配置项主要声明监听哪些属性，如childList，attributes等\n示例：_br_\n<pre><code>const elem = document.querySelector("#elem");\n// 创建观察者实例\nconst observer = new MutationObserver((mutationsList, observer) => {\n  // 监听回调\n});\nobserver.observe(elem, {\n  //至少要传一个配置\n  attributes: true,\n});\n// 元素发生改变\nelem.hidden = true;</code></pre>_br_\n配置：_br_\n<pre><code>\nobserve(target, options){\n  attributes：是否监听标签属性变化\n  childList：是否监听子节点变化\n  characterData：是否监听文本节点内容的变化\n  attributeOldValue：是否记录属性变化前的值\n  characterDataOldValue：是否记录文本节点内容变化前的值\n  subtree：是否监听后代节点变化\n  attributeFilter：过滤属性名称\n}</code></pre>_br_\n当我们需要取消监听标签变化时可以使用实例化对象MutationObserver的disconnect()函数进行中断。_br_\nMutationObserver的应用场景_br__hr_\n检测DOM变化并做出响应_br_\n比如使用MutationObserver实现图片懒加载，监视img标签的visibilitychange事件，做出响应；_br_或者当元素的偏移top在窗口内时做出加载图片操作_br__hr_\n动态样式变化_br_\n监听style或者class的变化做出响应，比如我之前的应用：监听antd的模态窗变化，做出后续操作_br__hr_\n标签之间通信_br_\n通过监听data-key属性的变化发送、接收消息_br__hr_\nMutationObserver固然好用，但是其缺点也比较明显_br_\n首先是性能损耗_br_\n虽然在MutationEvent的基础上优化了许多，但是监听body的操作对性能影响还是非常大的，一切用户操作可能都会使函数频繁的回调。_br_\n解决方式是尽量对小范围的节点进行监听，或者限制监听类型_br__hr_\n其次是操作冲突_br_\n由于回调函数非唯一性，如果两个观察者监听变化后的操作有依赖关系可能会造成错误或者冲突_br__hr_\n解决方式可以采用锁的机制，当两个条件都满足才能进入函数或者线程_br_\n最后是无法在IFrame中监听变化_br_\nMutationObserver操作是基于当前DOM进行监听的，所以无法跨线程与窗口。\n'},{articleName:"MessageChannel 消息通道",articleTitle:"MessageChannel 消息通道",articleTxt:'一、初识 MessageChannel 对象 _br_\n  通过构造函数 MessageChannel() 可以创建一个消息通道，实例化的对象会继承两个属性：port1 和 port2\n  port1 和 port2 都是 MessagePort 对象，在这里是只读的，无法对其进行字面量赋值\n  不过可以给 port 添加属性 _br_\n    MessagePort 对象具有 onmessage 和 onmessageerror 两个属性 _br_\n\n这是两个回调方法，使用 MessagePort.postMessage 方法发送消息的时候，就会触发另一个端口的 onmessage _br_\n消息通道就像是一条左右贯通的管道，左右两个端口就是 port1 和 port2\n这两个端口可以相互发送消息，port1 发送的消息可以在 port2 接收到，反之亦然 _br_\n<img\nalt=""\nsrc="'.concat("https://i.postimg.cc/fRFfJfBP/info2.png","\"\n/> _br_\n\n二、多个 Web Worker 之间通信 _br_\n\nMessageChannel 可以结合 Web Worker 实现多线程通信 _br_\nmain.js _br_\n<pre><code>let worker1 = new Worker('./worker1.js');\nlet worker2 = new Worker('./worker2.js');\nlet ms = new MessageChannel();\n// 把 port1 分配给 worker1\nworker1.postMessage('main', [ms.port1]);// 把 port2 分配给 worker2\nworker2.postMessage('main', [ms.port2]);\nworker2.onmessage = function(event) {\n}</code></pre> _br_\n worker1.js _br_\n<pre><code>onmessage = function(e) {\n  if (e.data === 'main') {\n      const port = e.ports[0];\n      port.postMessage('Hi! I'm worker1');\n  }       \n}</code></pre> _br_\n worker2.js _br_\n<pre><code>onmessage = function(e) {\n  if (e.data === 'main') {\n      const port = e.ports[0];\n      port.onmessage = function(e) {\n          postMessage(e.data);\n      }\n  }\n}</code></pre> _br_\n代码运行的时候，worker1 中通过 port1 发送消息，然后 worker2 就能从 port2 中接收到消息 _br_\n\n三、深拷贝 _br_\n\n大部分需要深拷贝的场景，都可以使用以下代码： _br_\n<pre><code>JSON.parse(JSON.stringify(object))</code></pre> _br_\n但这种办法会忽略 undefined、function、symbol 和循环引用的对象\n而通过 postMessage() 方法传输的 message 参数是深拷贝的 _br_\n所以可以借用 MessageChannel 实现深拷贝： _br_\n深拷贝函数 _br_\n<pre><code>function deepClone(val) {\nreturn new Promise(resolve => {\n  const { port1, port2 } = new MessageChannel()\n  port2.onmessage = e => resolve(e.data)\n  port1.postMessage(val)\n})\n}</code></pre> _br_\n 定义一个包含 undefined 的对象 _br_\n<pre><code>let obj = {\na: 'wise',\nb: undefined,\nc: {\n  d: 'wrong'\n}\n}\n// 循环引用\nobj.c.e = obj.c\n// 注意该方法是异步的\nasync function test() {\nconst clone = await deepClone(obj)\n}\ntest()</code></pre> _br_\n但这个深拷贝只能解决 undefined 和循环引用对象的问题，对于 Symbol 和 function 依然束手无策")},{articleName:"正则隐藏Bug-lastIndex",articleTitle:"正则隐藏Bug-lastIndex",articleTxt:'请查看并运行以下代码看看有什么问题? _br_\n  <pre><code><template>\n  <div class="demo">\n  <div>\n    <div>手机号：<input type="text" class="from-input" /></div>\n    <div class="from-msg">验证不通过</div>  \n  </div>\n</div>\n</template>\n<script>\nexport default {\n  mounted() {\n  const reg = /^1d{10}$/g;\n  const msg = document.querySelector(".from-msg");\n  const input = document.querySelector(".from-input");\n  input.oninput = function () {\n    if (reg.test(this.value)) {\n      msg.style.display = "none";\n    } else {\n      msg.style.display = "block";\n    }\n  };\n}\n};\n<\/script></code></pre> _br_\n执行完后是不是发现很神奇,报错提示居然一直显示,这不应该! _br_\n这里需要了解几个简单的知识点: _br_\n1、lasteIndex属性用于规定下次匹配的起始位置 _br_\n2、该属性只有设置标志 g 才能使用 _br_\n3、该属性是可读可写的 _br_\n4、当方法 exec() 或 test() 再也找不到可以匹配的文本时，它们会自动把 lastIndex 属性重置为 0。 _br_\n\n如果对于lastIndex还是不太清楚，可以执行以下代码 _br_\n<pre><code>let reg1 = /d/g; \nlet str1 = "as4f65ase4";\nconsole.log("从" + reg1.lastIndex + "开始查找");\nconsole.log(reg1.exec(str1));\nconsole.log("从" + reg1.lastIndex + "开始查找");\nconsole.log(reg1.exec(str1));\nconsole.log("从" + reg1.lastIndex + "开始查找");\nconsole.log(reg1.exec(str1));\nconsole.log("从" + reg1.lastIndex + "开始查找");</code></pre> _br_\n结论: _br_\n这个示例之所以运行不正常是因为console时多执行了一次reg.test导致lastIndex变化 _br_\n解决方式两种： _br_\n1. reg.lastIndex = 0 _br_ \n2. 将正则的全局 g 去掉'}]}}]);